#!/bin/bash
. "$(dirname "$0")/common"
. "$(dirname "$0")/defaults"

pidfile=$starbound_mod_updater_pidfile

loadModList() {
  # Resolve the modlist file path without shadowing global var
  local modlist_path="$modlist_directory/$modlist_file"
  local mod_ids_temp=()
  
  if [ ! -f "$modlist_path" ]; then
    debug "Modlist file not found: $modlist_path"
    return 1
  fi
  
  while IFS= read -r line || [ -n "$line" ]; do
    # Skip comments and empty lines
    if [[ "$line" =~ ^[[:space:]]*# ]] || [[ "$line" =~ ^[[:space:]]*$ ]]; then
      continue
    fi
    
    # Extract mod ID (first word/number)
      # Extract mod ID (first word/number) without forking awk
      local mod_id=${line%% *}
    
    # Validate mod ID is numeric
    if [[ "$mod_id" =~ ^[0-9]+$ ]]; then
      mod_ids_temp+=("$mod_id")
    else
      warn "Invalid mod ID format: $line"
    fi
  done < "$modlist_path"
  
  if [ ${#mod_ids_temp[@]} -eq 0 ]; then
    debug "No valid mod IDs found in modlist"
    return 1
  fi
  
  mod_ids=("${mod_ids_temp[@]}")
  return 0
}

loadCurrentVersions() {
  # Initialize JSON file if missing
  if [ ! -f "$mod_version_file_path" ]; then
    debug "Mod version file not found: $mod_version_file_path â€” initializing JSON"
    mkdir -p "$(dirname "$mod_version_file_path")"
    echo '{"mods":[]}' > "$mod_version_file_path"
  fi
  # Load each mod id and timestamp into array current_versions
  mapfile -t current_versions < <(jq -r '.mods[] | "\(.id) \(.timestamp)"' "$mod_version_file_path")
}

saveCurrentVersions() {
  local versions=("$@")
  mkdir -p "$(dirname "$mod_version_file_path")"
  # Build JSON with jq from input lines "id timestamp"
  printf '%s\n' "${versions[@]}" | jq -Rn '
    [inputs
      | split(" ")
      | {id:(.[0]|tonumber), timestamp:(.[1]|tonumber)}
    ] as $mods
    | {mods: $mods}
  ' > "$mod_version_file_path"
}

pruneRemovedMods() {
  # Batch-filter JSON to keep only active mods
  local ids_json
  ids_json=$(printf '%s\n' "$@" | jq -R . | jq -s 'map(tonumber)')
  jq --argjson actives "$ids_json" '
    # Log removals and remove directories via side effects
    ( .mods
      | to_entries
      | map(
          if (.value.id as $i | $actives | index($i)) then .value
          else (
            .value | @sh "info Removing version entry for mod \(.id) (no longer in mod list)" | wall; 
            @sh "rm -rf \($ENV.mod_directory)/\(.id)" | wall;
            empty
          )
        )
    ) as $filtered
    | { mods: $filtered }
  ' "$mod_version_file_path" > "${mod_version_file_path}.tmp" \
    && mv "${mod_version_file_path}.tmp" "$mod_version_file_path"
}

getModTimestamp() {
  local mod_id=$1
  local response
  local steam_web_api=https://api.steampowered.com/IPublishedFileService/GetDetails/v1
  
  response=$(curl -s "$steam_web_api?itemcount=1&publishedfileids[0]=$mod_id")
  
  if [ $? -ne 0 ] || [ -z "$response" ]; then
    debug "Failed to fetch mod info for $mod_id"
    return 1
  fi
  
  # Extract time_updated from JSON response
  local timestamp=$(echo "$response" | grep -o '"time_updated":[0-9]*' | cut -d':' -f2)
  
  if [ -n "$timestamp" ] && [ "$timestamp" -gt 0 ]; then
    echo "$timestamp"
    return 0
  fi
  
  debug "Could not extract timestamp for mod $mod_id"
  return 1
}

getCurrentModTimestamp() {
  local mod_id=$1
  local timestamp
  timestamp=$(jq -r --arg id "$mod_id" '.mods[] | select(.id == ($id|tonumber)) | .timestamp' "$mod_version_file_path")
  if [ -z "$timestamp" ] || [ "$timestamp" = "null" ]; then
    return 1
  fi
  echo "$timestamp"
}

checkForModUpdates() {
  local mod_ids=("$@")
  local updates_tmp=()
  local MAX_PARALLEL=10

  # Write IDs to temp file for resilience & parallel execution
  local id_file
  id_file="$(mktemp)"
  printf '%s\n' "${mod_ids[@]}" > "$id_file"

  # Fetch timestamps in parallel; produce lines "id timestamp" (empty ts on failure)
  mapfile -t _results < <(
    xargs -a "$id_file" -n1 -P "$MAX_PARALLEL" bash -c ' \
      id="$0"; \
      if ts=$(getModTimestamp "$id"); then \
        echo "$id $ts"; \
      else \
        echo "$id "; \
      fi' _
  )

  # Clean up
  rm -f "$id_file"

  # Compare against cache and build update list
  for entry in "${_results[@]}"; do
    local mod_id=${entry%% *}
    local latest_timestamp=${entry#* }
    if [ -z "$latest_timestamp" ]; then
      warn "Could not check update for mod $mod_id - skipping"
      continue
    fi

    if current_timestamp=$(getCurrentModTimestamp "$mod_id"); then
      if [ "$latest_timestamp" -gt "$current_timestamp" ]; then
        info "Update available for mod $mod_id (current: $current_timestamp, latest: $latest_timestamp)"
        updates_tmp+=("$mod_id")
      else
        debug "Mod $mod_id is up to date"
      fi
    else
      info "New mod detected: $mod_id"
      updates_tmp+=("$mod_id")
    fi
  done

  update_list=( "${updates_tmp[@]}" )
  [ ${#update_list[@]} -gt 0 ]
}

downloadMods() {
  local mod_ids=("$@")
  local download_args=""
  
  mkdir -p "$mod_directory"
  
  # Build SteamCMD workshop download arguments
  for mod_id in "${mod_ids[@]}"; do
    download_args="$download_args +workshop_download_item $steam_app_id $mod_id"
  done
  
  info "Downloading ${#mod_ids[@]} mods via SteamCMD..."
  
  su starbound -c "
    export HOME=/home/starbound
    $steamcmd_path +force_install_dir \"$install_path\" +login anonymous $download_args +quit
  "
  
  if [ $? -ne 0 ]; then
    error "SteamCMD mod download failed"
    return 1
  fi
  
  # Move downloaded mods to mod directory
  local workshop_content_path="$install_path/steamapps/workshop/content/$steam_app_id"
  
  if [ -d "$workshop_content_path" ]; then
    for mod_id in "${mod_ids[@]}"; do
      local mod_source="$workshop_content_path/$mod_id"
      local mod_dest="$mod_directory/$mod_id"
      
      if [ -d "$mod_source" ]; then
        rm -rf "$mod_dest"
        mv "$mod_source" "$mod_dest"
        info "Installed mod $mod_id"
      else
        warn "Downloaded mod $mod_id not found in expected location"
      fi
    done
    
    # Clean up workshop directory
    rm -rf "$workshop_content_path"
  else
    warn "Workshop content directory not found after download"
  fi
  
  return 0
}

updateModVersions() {
  local mod_ids=("$@")
  # Build updates JSON from new timestamps
  local updates_json
  updates_json=$(for mod_id in "${mod_ids[@]}"; do
    if timestamp=$(getModTimestamp "$mod_id"); then
      printf '{"id":%s,"timestamp":%s}\n' "$mod_id" "$timestamp"
    fi
  done | jq -s '.')
  # Merge updates into the version file in one jq call
  jq --argjson updates "$updates_json" '
    .mods |= map(
      if (.id as $i | ($updates | map(.id) | index($i))) then
        (. as $m | ($updates[] | select(.id == $m.id) | .timestamp) as $t | $m | .timestamp = $t)
      else
        .
      end
    )
  ' "$mod_version_file_path" > "${mod_version_file_path}.tmp" \
    && mv "${mod_version_file_path}.tmp" "$mod_version_file_path"
}

updateMods() {
  local mod_ids
  local updates_needed
  
  # PID lock check
  if [ -f "$pidfile" ]; then
    info "Found existing mod updater PID file - checking process"
    checkLock $pidfile
  fi
  trap shutdownModUpdater SIGINT SIGTERM
  
  # Start update process
  doModUpdate &
  starbound_mod_updater_pid=$!
  echo $starbound_mod_updater_pid >"$pidfile"
  wait $starbound_mod_updater_pid
}

doModUpdate() {
  info "Starting mod update check..."
  
  # Load mod list
  if ! loadModList; then
    info "No mods configured - skipping mod update"
    clearLock "$pidfile"
    return 0
  fi
  mod_array=( "${mod_ids[@]}" )
  info "Found ${#mod_array[@]} mods in mod list"
  
  # Prune removed mods
  pruneRemovedMods "${mod_array[@]}"
  
  # Check for updates
  if checkForModUpdates "${mod_array[@]}"; then
    update_array=( "${update_list[@]}" )
    
    if [ ${#update_array[@]} -gt 0 ]; then
      info "Found ${#update_array[@]} mod updates needed"
      
      # Download updated mods
      if downloadMods "${update_array[@]}"; then
        updateModVersions "${update_array[@]}"
        info "Mod updates completed successfully"
      else
        error "Mod download failed"
        clearLock "$pidfile"
        return 1
      fi
    else
      info "All mods are up to date"
    fi
  else
    info "All mods are up to date"
  fi
  
  clearLock "$pidfile"
}

shutdownModUpdater() {
  debug "Received signal to shut down mod updater"
  clearLock "$pidfile"
}
